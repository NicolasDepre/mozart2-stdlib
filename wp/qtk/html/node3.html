<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>3 Tutorial Example : a simple word processing application</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html#chapter.prototyper">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node4.html#chapter.basics">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.example"><H1><A name="chapter.example">3 Tutorial Example : a simple word processing application</A></H1><P>The example given in this chapter describes how a gui is built using QTk module. The creation of the widgets, their geometry inside the window and their interaction with Mozart are described. </P><DIV id="figure.picture3"><HR><P><A name="figure.picture3"></A></P><DIV align="center"><IMG alt="" src="picture3.gif"></DIV><P class="caption"><STRONG>Figure&nbsp;3.1:</STRONG> Notepad application</P><HR></DIV><P></P><H2><A name="label2">3.1 Geometry management</A></H2><P>The example application will consist of a window composed by </P><UL><LI><P>A toolbar with the following buttons : Save, Load and Quit.</P></LI><LI><P>A main area where the user can type the text.</P></LI></UL><P> The construction of a window is completely described by a record. This record defines the widgets that compose the window, how these widgets must be placed and what is their behaviour is they must be resized. The label of the record defines the widget that must be placed. The content of the record defines the parameters of the widget. Some widgets act as containers for other widgets. The two main containers are : </P><UL><LI><P><CODE>td</CODE> : all widgets contained in this one are placed top to down</P></LI><LI><P><CODE>lr</CODE> : all widgets contained in this one are placed left to right</P></LI></UL><P> The toolbar wil be composed of <CODE>button</CODE> widgets. The <CODE>text</CODE> parameter defines the text of the button. </P><DIV id="figure.picture1"><HR><P><A name="figure.picture1"></A></P><DIV align="center"><IMG alt="" src="picture1.gif"></DIV><P class="caption"><STRONG>Figure&nbsp;3.2.</STRONG></P><HR></DIV><P>The toolbar is described by : </P><BLOCKQUOTE class="code"><CODE>Toolbar=lr(button(text:<SPAN class="string">&quot;Save&quot;</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Load&quot;</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Quit&quot;</SPAN>))</CODE></BLOCKQUOTE><P> which literally means : place these three buttons respectively from left to right, each button taking the size it needs to display itself. Combining with the text widget, we obtain : </P><BLOCKQUOTE class="code"><CODE>Description=td(Toolbar<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text)</CODE></BLOCKQUOTE><P> which literally means : place the toolbar and the text respectively from top to bottom, each widget taking the size it needs to display itself.</P><P>Now we can build a window from this description by the command : </P><BLOCKQUOTE class="code"><CODE>Window={QTk<SPAN class="keyword">.</SPAN>build&nbsp;Description}</CODE></BLOCKQUOTE><P> This window is hidden by default, so you have to show it to make it visible : </P><BLOCKQUOTE class="code"><CODE>{Window&nbsp;show}</CODE></BLOCKQUOTE><P> If you resize the window, the widgets don't resize in a very clever way inside the window. </P><DIV id="figure.picture2"><HR><P><A name="figure.picture2"></A></P><DIV align="center"><IMG alt="" src="picture2.gif"></DIV><P class="caption"><STRONG>Figure&nbsp;3.3.</STRONG></P><HR></DIV><P>One expects the toolbar to stick itself to the top left of the window, and the text widget to take all remaining available size below. All widgets have a glue parameter that allow to specify contraints to the geometry manager. Valid values for the glue parameters are atoms that are combinations of <CODE>n</CODE>, <CODE>s</CODE>, <CODE>w</CODE> and <CODE>e</CODE>. By default a widget takes as much place as it needs to draw itself, and if the area in which it is drawed is bigger than that size, the widget is centered inside. By specifying <CODE>n</CODE> (resp <CODE>s</CODE>, <CODE>w</CODE>, <CODE>e</CODE>) you enforce the north (resp south, west and east) border of the widget to glue to its top (resp down, left, right) neighboor. If you specify both <CODE>ns</CODE> (resp <CODE>we</CODE>) you enforce both opposite border to stick to their respective neighboor, resulting in the widget taking all the vertical (resp horizontal) space available.</P><P>Using the glue parameter we define : </P><BLOCKQUOTE class="code"><CODE>Toolbar=lr(glue:we&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="comment">%&nbsp;the&nbsp;toolbar&nbsp;glues&nbsp;itself&nbsp;to&nbsp;the&nbsp;top&nbsp;left&nbsp;of&nbsp;the&nbsp;window<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Save&quot;</SPAN>&nbsp;glue:w)&nbsp;&nbsp;<SPAN class="comment">%&nbsp;the&nbsp;button&nbsp;glues&nbsp;itself&nbsp;to&nbsp;the&nbsp;left&nbsp;of&nbsp;the&nbsp;lr&nbsp;widget<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Load&quot;</SPAN>&nbsp;glue:w)&nbsp;&nbsp;<SPAN class="comment">%&nbsp;idem<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button(text:<SPAN class="string">&quot;Quit&quot;</SPAN>&nbsp;glue:w))&nbsp;<SPAN class="comment">%&nbsp;idem</SPAN></CODE></BLOCKQUOTE><P> and also </P><BLOCKQUOTE class="code"><CODE>Description=td(Toolbar<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text(glue:nswe))</CODE></BLOCKQUOTE><P> Note that the very first <CODE>td</CODE> or <CODE>lr</CODE> widget is always implicitely <CODE>glue:nswe</CODE>. Rebuilding and showing the window, we obtain an application that has a complete graphical user interface, except that it is an empty shell.</P><H2><A name="label3">3.2 Interaction with the user</A></H2><P>An action can be associated to buttons. It is executed when the user clicks the button : </P><BLOCKQUOTE class="code"><CODE>button(text:<SPAN class="string">&quot;Quit&quot;</SPAN>&nbsp;glue:w&nbsp;action:<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{Application<SPAN class="keyword">.</SPAN>exit&nbsp;0})}</CODE></BLOCKQUOTE><P> This definition makes the oz application terminate when the user clicks the Quit button. Another parameter for closes the window : </P><BLOCKQUOTE class="code"><CODE>button(text:<SPAN class="string">&quot;Quit&quot;</SPAN>&nbsp;glue:w&nbsp;action:toplevel<SPAN class="keyword">#</SPAN>close)</CODE></BLOCKQUOTE><P> Let's make procedures for the Save and Load buttons. The new definitions for these buttons are thus : </P><BLOCKQUOTE class="code"><CODE>button(text:<SPAN class="string">&quot;Save&quot;</SPAN>&nbsp;glue:w&nbsp;action:SaveText)<BR>button(text:<SPAN class="string">&quot;Load&quot;</SPAN>&nbsp;glue:w&nbsp;action:LoadText)</CODE></BLOCKQUOTE><P> The <CODE>LoadText</CODE> and <CODE>SaveText</CODE> procedures will do these things : </P><UL><LI><P>Ask a filename. Standard dialog boxes are provided in QTk : <CODE>{QTk<SPAN class="keyword">.</SPAN>dialogbox&nbsp;load(<SPAN class="keyword">...</SPAN>)}</CODE> and <CODE>{QTk<SPAN class="keyword">.</SPAN>dialogbox&nbsp;save(<SPAN class="keyword">...</SPAN>)}</CODE></P></LI><LI><P>Get the contents of the text widget and save it to the file or get the contents of the file and change the contents of the text widget accordingly.</P></LI></UL><P> We need a way to dynamically change or get its state, i.e. interact with the widget. This can be done with an handle : </P><BLOCKQUOTE class="code"><CODE>TextHandle<BR>Description=td(Toolbar<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text(glue:nswe&nbsp;handle:TextHandle))</CODE></BLOCKQUOTE><P> After the window is built, the unbound variable TextHandle is bound to an object that controls the text widget. The current text can be obtained by : </P><BLOCKQUOTE class="code"><CODE>{TextHandle&nbsp;get($)}</CODE></BLOCKQUOTE><P> and set by : </P><BLOCKQUOTE class="code"><CODE>{TextHandle&nbsp;set($)}</CODE></BLOCKQUOTE><P> We can now give the <CODE>SaveText</CODE> and <CODE>LoadText</CODE> procedures : </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">SaveText</SPAN>}<BR>&nbsp;&nbsp;Name={QTk<SPAN class="keyword">.</SPAN>dialogbox&nbsp;save($)}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;File={New&nbsp;Open<SPAN class="keyword">.</SPAN>file&nbsp;init(name:Name&nbsp;flags:[write&nbsp;create])}<BR>&nbsp;&nbsp;&nbsp;&nbsp;Contents={TextHandle&nbsp;get($)}<BR>&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;{File&nbsp;write(vs:Contents)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;{File&nbsp;close}<BR>&nbsp;&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;_&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR><SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">LoadText</SPAN>}<BR>&nbsp;&nbsp;Name={QTk<SPAN class="keyword">.</SPAN>dialogbox&nbsp;load($)}<BR>&nbsp;&nbsp;Contents={TextHandle&nbsp;get($)}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;File={New&nbsp;Open<SPAN class="keyword">.</SPAN>file&nbsp;init(name:Name)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;Contents={File&nbsp;read(list:$&nbsp;size:all)}<BR>&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;{TextHandle&nbsp;set(Contents)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;{File&nbsp;close}<BR>&nbsp;&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;_&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> And the application is now complete.</P><H2><A name="label4">3.3 Enhancements</A></H2><P>Instead of using standard buttons, we might want to use a toolbar look and feel. A QTk widget does that : <CODE>tbbutton</CODE>. As its interface is the same as standard buttons, we just have to change le label of the record : </P><BLOCKQUOTE class="code"><CODE>Toolbar=lr(glue:we<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbbutton(text:<SPAN class="string">&quot;Save&quot;</SPAN>&nbsp;glue:w)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbbutton(text:<SPAN class="string">&quot;Load&quot;</SPAN>&nbsp;glue:w)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbbutton(text:<SPAN class="string">&quot;Quit&quot;</SPAN>&nbsp;glue:w))</CODE></BLOCKQUOTE><P> If there is a lot of text, scrollbars are usefull to allow easy mouse navigation. This can be added with a parameter : </P><BLOCKQUOTE class="code"><CODE>text(glue:nswe&nbsp;handle:TextHandle&nbsp;tdscrollbar:<SPAN class="keyword">true</SPAN>)</CODE></BLOCKQUOTE><P> Moreover one may prefer the white color as background color for the text : </P><BLOCKQUOTE class="code"><CODE>text(glue:nswe&nbsp;handle:TextHandle&nbsp;tdscrollbar:<SPAN class="keyword">true</SPAN>&nbsp;bg:white)</CODE></BLOCKQUOTE><P> As you can see, widgets are highly configurable by parameters. Most of these parameters can be dynamically changed : </P><BLOCKQUOTE class="code"><CODE>{TextHandle&nbsp;set(bg:white)}</CODE></BLOCKQUOTE><P> Sets also the background to white but it can be done at any time as soon as the window is built and as long as it isn't closed. Interfaces to widgets were made as uniform as possible and similar widgets have similar parameters name and use. </P><H2><A name="label5">3.4 The complete code</A></H2><P class="margin"><A href="notepad.oz">Source File</A></P><P> </P><BLOCKQUOTE><PRE><SPAN class="keyword">declare</SPAN>&nbsp;<BR>[QTk]={Module<SPAN class="keyword">.</SPAN>link&nbsp;[<SPAN class="string">&quot;http://www.info.ucl.ac.be/people/ned/qtk/QTk.ozf&quot;</SPAN>]}<BR>&nbsp;<BR><SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">SaveText</SPAN>}<BR>&nbsp;&nbsp;&nbsp;Name={QTk<SPAN class="keyword">.</SPAN>dialogbox&nbsp;save($)}<BR><SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File={New&nbsp;Open<SPAN class="keyword">.</SPAN>file&nbsp;init(name:Name&nbsp;flags:[write&nbsp;create])}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contents={TextHandle&nbsp;get($)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{File&nbsp;write(vs:Contents)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{File&nbsp;close}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;_&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;<BR><SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">LoadText</SPAN>}<BR>&nbsp;&nbsp;&nbsp;Name={QTk<SPAN class="keyword">.</SPAN>dialogbox&nbsp;load($)}<BR><SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File={New&nbsp;Open<SPAN class="keyword">.</SPAN>file&nbsp;init(name:Name)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contents={File&nbsp;read(list:$&nbsp;size:all)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{TextHandle&nbsp;set(Contents)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{File&nbsp;close}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;_&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR>Toolbar=lr(glue:we<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbbutton(text:<SPAN class="string">&quot;Save&quot;</SPAN>&nbsp;glue:w&nbsp;action:SaveText)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbbutton(text:<SPAN class="string">&quot;Load&quot;</SPAN>&nbsp;glue:w&nbsp;action:LoadText)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbbutton(text:<SPAN class="string">&quot;Quit&quot;</SPAN>&nbsp;glue:w&nbsp;action:toplevel<SPAN class="keyword">#</SPAN>close))<BR>&nbsp;<BR>TextHandle<BR>&nbsp;<BR>Window={QTk<SPAN class="keyword">.</SPAN>build&nbsp;td(Toolbar<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text(glue:nswe&nbsp;handle:TextHandle&nbsp;bg:white&nbsp;tdscrollbar:<SPAN class="keyword">true</SPAN>))}<BR>&nbsp;<BR>{Window&nbsp;show}<BR>&nbsp;<BR></PRE></BLOCKQUOTE><P></P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html#chapter.prototyper">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node4.html#chapter.basics">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS>Donatien Grolaux<BR><SPAN class="version">Version 1.2.3 (20011129)</SPAN></ADDRESS></BODY></HTML>
